<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Java 9 // A review of the features includes</title>

    <meta name="description" content="A web presentation about STREAM API">
    <meta name="author" content="Juan Antonio Breña Moral | Víctor Herraiz Posada | Juan Antonio Medina">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="./Styles/reveal.css">
    <link rel="stylesheet" href="./Styles/black.css" id="theme">
    <link rel="stylesheet" href="./Styles/zenburn.css">
</head>
<body>
    <div class="reveal">

        <div class="slides">
            <section data-background="./Images/java92.jpg">
                <h1 style="color:red">Java 9</h1>
                <h3 style="color:black">A review of <a href="http://openjdk.java.net/projects/jdk9/spec/" target="_blank">JSR (379)</a></h3>
                <i>Juan Antonio Breña Moral</i><br />
                <i>Víctor Herraiz Posada</i><br />
                <i>Juan Antonio Medina</i>
            </section>
            <section
                    data-background="./Images/g1.png"
                    data-background-repeat="repeat"
                    data-background-size="300px"
                    style="color:black">
                <h2 style="color:black">Agenda</h2>
                <ol>
                    <li style="display: block; background: #808080;"><span style="display: inline-block; background: #DFFF6D; width:100px;">000.</span> Introduction</li>
                    <li style="display: block; background: #808080;"><span style="display: inline-block; background: #DFFF6D; width:100px;">001.</span> Java Platform Module System &nbsp;</li>
                    <li style="display: block; background: #808080;"><span style="display: inline-block; background: #DFFF6D; width:100px;">010.</span> Concurrency Updates</li>
                    <li style="display: block; background: #808080;"><span style="display: inline-block; background: #DFFF6D; width:100px;">011.</span> The Java Shell</li>
                    <li style="display: block; background: #808080;"><span style="display: inline-block; background: #DFFF6D; width:100px;">100.</span> The Garbage first collector (G1) &nbsp;</li>
                    <li style="display: block; background: #808080;"><span style="display: inline-block; background: #DFFF6D; width:100px;">101.</span> Streams improvements</li>
                </ol>
            </section>
            <section>
                <section
                        data-background="./Images/java.png"
                        data-background-repeat="repeat"
                        data-background-size="200px">
                    <h2>Introduction</h2>
                    <pre><code class="gherkin">
Feature: Review JSR 379
         Teach some points about JSR 379

    Background: Audience with heteregeneous Java/JVM skills

    Scenario: The talk begin
        Given A listener with interest to learn about Java 9
        Then The talker will explain the introduction:

| # | Point                               |
| 1 | JEP vs JRS                          |
| 3 | List of features included on Java 9 |
                    </code></pre>
                </section>
                <section>
                    <h3>JEP vs JSR</h3>
                    <p>
                        <strong>JDK Enhancement Proposal (JEP):</strong>
                        is a process for collecting proposals for enhancements to the Java Development Kit and OpenJDK.
                    </p>
                    <p>
                        <a href="https://en.m.wikipedia.org/wiki/JDK_Enhancement_Proposal" target="_blank">https://en.m.wikipedia.org/wiki/JDK_Enhancement_Proposal</a>
                    </p>
                    <p>
                        <strong>Java Specification Requests (JSR):</strong>
                        are the actual descriptions of proposed and final specifications for the Java platform.
                    </p>
                    <p>
                        <a href="https://jcp.org/en/jsr/overview" target="_blank">https://jcp.org/en/jsr/overview</a>
                    </p>
                </section>
                <section>
                    <h3>Features includes with Java 9</h3>
                    <p>
                    How many days to release Java 9?
                    </p>
                    <p>
                        <a href="http://www.java9countdown.xyz/" target="_blank">http://www.java9countdown.xyz/</a>
                    </p>
                    <p>
                        Do you know the list of features included?
                    </p>
                    <p>
                        <a href="http://openjdk.java.net/projects/jdk9/" target="_blank">http://openjdk.java.net/projects/jdk9/</a>
                    </p>
                 </section>
                <section data-background="./Images/java9_categories.png">

                </section>
            </section>
            <section>
                <section data-background="./Images/jigsaw1.jpg">
                    <h2 style="color:black">JSR 376: JIGSAW</h2>
                    <pre><code class="gherkin">
Feature: Review The Java Platform Module System

    Scenario: Java projects will have to compiled with Java 9 JVM
        Given The developer need to know the changes
        Then The talker will explain the following points:

| # | Point                        |
| 1 | Introduction                 |
| 2 | Why we need a Module system? |
| 3 | API Reorganization           |
| 4 | How to create a Module?      |
| 5 | Build systems                |
| 6 | Open issues                  |
| 7 | Conclusions                  |
                    </code></pre>
                </section>
                <section>
                    <h3>Introduction</h3>
                    <ul>
                        <li><a href="http://openjdk.java.net/projects/jigsaw/spec/" target="_blank">JSR 376: Java Platform Module System</a></li>
                        <li><a href="http://openjdk.java.net/jeps/161" target="_blank">JEP 161: Compact Profiles</a></li>
                        <li><a href="http://openjdk.java.net/jeps/162" target="_blank">JEP 162: Prepare for Modularization</a></li>
                        <li><a href="http://openjdk.java.net/jeps/200" target="_blank">JEP 200: The Modular JDK</a></li>
                        <li><a href="http://openjdk.java.net/jeps/260" target="_blank">JEP 260: Encapsulate Most Internal APIs</a></li>
                        <li><a href="http://openjdk.java.net/jeps/261" target="_blank">JEP 261: Module System</a></li>
                        <li><a href="http://openjdk.java.net/jeps/282" target="_blank">JEP 282: jlink: The Java Linker</a></li>
                        <li><a href="http://openjdk.java.net/jeps/220" target="_blank">JEP 220: Modular Run-Time Images</a></li>
                        <li><a href="http://openjdk.java.net/jeps/201" target="_blank">JEP 201: Modular Source Code</a></li>
                        <li><a href="http://openjdk.java.net/jeps/275" target="_blank">JEP 275: Modular Java Application Packaging</a></li>
                        <li><a href="http://openjdk.java.net/jeps/238" target="_blank">JEP 238: Multi-Release JAR Files</a></li>
                    </ul>
                </section>
                <section>
                    <h2>Introduction</h2>
                    <p>
Jigsaw updates some points in the JVM architecture:
                    </p>
                    <img src="Images/JVM_Architecture2.jpg" />
                </section>
                <!--
                <section>
                    <h3>Why we need a Module system?</h3>
                    <p>
                        Software can be seen as a system of interacting parts and in Java it is common to package each of those parts in its own JAR.
                        Conceptually a part consists of three properties: a name, a public API for the rest of the world to use, and dependencies on other parts.
                        This graph-like model helps developers and tools dissect, analyse, and work with software systems.
                    </p>
                </section>
                -->
                <section>
                    <h3>Why we need a Module system?</h3>
                    <p>
                        <strong>JVM Classloader:</strong>
                    </p>
                    <img src="./Images/jvm_classloader.png" />
                </section>
                <section>
                    <h3>Why we need a Module system?</h3>
                    <p>
                        <strong>JVM Classloader:</strong>
                    </p>
                    <img src="./Images/salad_bowl.jpg" width="40%" />
                </section>
                <section>
                    <h3>JEP 161: Compact Profiles</h3>
                    <img src="./Images/java8_compactProfiles.jpg" width="50%" />
                </section>
                <section data-background="#FFFFFF">
                    <h3>JEP 200: The Modular JDK</h3>
                    <img src="./Images/jdk1.png" width="80%" />
                </section>
                <section data-background="#FFFFFF">
                    <h3>JEP 200: The Modular JDK</h3>
                    <img src="./Images/jdk2.png" width="80%" />
                    <p>
                        <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank">https://docs.oracle.com/javase/8/docs/api/</a>
                    </p>
                    <p>
                        <a href="http://download.java.net/java/jdk9/docs/api/index.html?overview-summary.html" target="_blank">http://download.java.net/java/jdk9/docs/api/index.html?overview-summary.html</a>
                    </p>
                </section>
                <section>
                    <h3>Jigsaw project</h3>
                    <ul>
                        <li>Modularity for the Java platform</li>
                        <ul>
                            <li>Reliable configuration (goodbye classpath)</li>
                            <li>Strong encapsulation (goodbye com.sun)</li>
                        </ul>
                        <li>Enforce strict boundaries between modules</li>
                        <ul>
                            <li>compile-time</li>
                            <li>run-time</li>
                        </ul>
                    </ul>
                </section>

                <section>
                    <h3>How to create a module</h3>
                    <p>module-info.java</p>
                    <pre><code class="hljava" data-trim contenteditable>
module org.example @ 1.0 {
    requires jdk.base;
    requires com.google.guava @ 18.0;
    exports org.example.api;
}
                    </code></pre>
                </section>
                <section>
                    <pre><code class="hljava" data-trim contenteditable>
export JAVA_HOME=/Library/Java/Home
gradle init --type java-library
                    </code></pre>
                </section>
                <section>
                    <pre><code class="hljava" data-trim contenteditable>

java version "9-ea"
time java -verbose:class --module-path ./build/libs -m demo/demo.HelloWorld
0,42s user 0,07s system 80% cpu 0,600 total
780 classes loaded

java version "9-ea"
time java -verbose:class -jar hello_world-0.1.0-SNAPSHOT.jar
0,26s user 0,05s system 75% cpu 0,419 total
594 classes loaded

java version "1.8.0_121"
time java -verbose:class -jar hello_world-0.1.0-SNAPSHOT.jar
0,13s user 0,03s system 50% cpu 0,311 total
480 classes loaded

                    </code></pre>
                </section>
                <section>
                    <h3>Open issues</h3>
                    <p>
                        <a href="http://openjdk.java.net/projects/jigsaw/spec/issues/" target="_blank">Open Issues</a>
                    </p>
                </section>
            </section>
            <section data-background="#ffffff">
                <h2>Concurrency updates</h2>
                <img src="Images/java_Concurrency.gif" />
            </section>
            <section data-background="Images/jshell_help.jpg">
                <h2>JShell</h2>
            </section>
            <section>
                <section data-background="white">
                    <h2>The Garbage first collector (G1)</h2>
                    <img src="Images/garbage-collection.png" />
                </section>
                <section data-background="white">
                <h2>Java Heap</h2>
                <p>Java objects reside in an area called the heap.</p>
                <p>Is created when the JVM starts up and may increase or decrease in size while the application runs.</p>
                <p>When the heap becomes full, garbage is collected.</p>
                <p>Note that the JVM uses more memory than just the heap. Java methods, thread stacks and native handles are allocated in memory separate from the heap, as well as JVM internal data structures.</p>
                </section>
                <section data-background="white">
                    <h2>Garbage Collector</h2>
                    <p>A garbage collector automatically handles freeing of unused object memory by reclaiming when it can prove that is no longer accessible.</p>
                    <p>Traditionally, garbage collection has been considered an inefficient process, with modern technology performance is actually better than explicit freeing of objects.</p>
                </section>
                <section data-background="./Images/maxresdefault.jpg" style="color:black">
                </section>
                <section data-background="white">
                    <h3>Serial Collector</h3>
                    <p>Mainly designed for single-threaded environments and for small heaps.</p>
                    <p>This collector freezes all application threads whenever it’s working, which disqualifies it for all intents and purposes from being used in a server environment.</p>
                </section>
                <section data-background="white">
                    <h3>Parallel collector</h3>
                    <p>Its biggest advantage is that is uses multiple threads to scan through and compact the heap.</p>
                    <p>The downside to the parallel collector is that it will stop application threads when performing either a minor or full GC collection.</p>
                    <p>The parallel collector is best suited for apps that can tolerate application pauses and are trying to optimize for lower CPU overhead caused by the collector.</p>
                </section>
                <section data-background="white">
                    <h3>Concurrent-Mark-Sweep collector</h3>
                    <p>Uses multiple threads (“concurrent”) to scan through the heap (“mark”) for unused objects that can be recycled (“sweep”).</p>
                    <p>Uses more CPU to provide continuous throughput, by using multiple threads.</p>
                    <p>For most long-running server applications which are adverse to application freezes, that’s usually a good trade off to make.</p>
                </section>
                <section data-background="white">
                    <h3>G1 collector</h3>
                    <p>The Garbage first collector (G1) introduced in JDK 7 designed to better support heaps larger than 4GB.</p>
                    <p>Utilizes multiple background threads to scan through the heap divides into regions, from 1MB to 32MB (depending on heap size), the goal is to have around 2048 regions.</p>
                    <p>G1 collector is geared towards scanning those regions that contain the most garbage objects first, giving it its name (Garbage first).</p>
                </section>
                <section data-background="white">
                    <h3>G1 Basics</h3>
                    <p>Is an incremental parallel compacting GC that provides more predictable pause times compared to CMS and Parallel.</p>
                    <p>Introducing a parallel, concurrent and multi-phased marking cycle.</p>
                    <p>Can work with much larger heaps while providing reasonable worst-case pause times.</p>
                    <p>The basic idea your set your heap ranges and a realistic (soft real time) pause time goal and then let the GC do its job.</p>
                </section>
                <section data-background="white">
                    <h3>Old Heap Layout</h3>
                    <p>Conventional GC layout a contiguous Java heap splits into (contiguous) young and old generations.</p>
                    <img src="./Images/old_heap.jpg">
                </section>
                <section data-background="white">
                    <h3>G1 Heap Layout</h3>
                    <img src="./Images/g1_heap.jpg">
                </section>
                <section data-background="white">
                    <h3>G1 Regions</h3>
                    <p>Heap space divides into amultiple fixed-sized regions.</p>
                    <p>As the need arises, the free regions are assigned to either the young or the old generation.</p>
                    <p>Once a region frees up, it goes back to the "free" regions list.</p>
                    <p>Reclaim heap as much as possible (trying to meet the pause time goal) collecting regions with the least amount of live data, the ones with most garbage.</p>
                </section>
                <section data-background="white">
                    <h3>Young Generations</h3>
                    <p>Contains eden regions or survivor regions.</p>
                    <p>These regions provide the same function as the respective contiguous spaces in other collectors, with the difference that are typically laid out in a noncontiguous pattern in memory.</p>
                    <h3>Old Generations</h3>
                    <p>Old regions make up the old generation. Old generation regions may be humongous, that is they might span multiple regions.</p>
                </section>
                <section data-background="white">
                    <h3>Allocation</h3>
                    <p>An application always allocates into a young generation, that is, eden regions, with the exception of humongous, objects that are directly allocated as belonging to the old generation.</p>
                    <p>G1 can reclaim space in young generations as a whole, and any additional set of old generation regions.</p>
                </section>
                <section data-background="white">
                    <h3>Copyng</h3>
                    <p>G1 copies objects from a collection set to one or more different regions.</p>
                    <p>The destination depends on the source:</p>
                    <p>Entire young generation is copied into either survivor or old regions, and objects from old regions to other, different old regions using aging.</p>
                </section>
                <section data-background="white">
                    <h3>Garbage Collection Cycle</h3>
                    <img src="./Images/collection_cycle.png">
                    <p>Collector alternates between two phases. 'Young-only' contains garbage collections that fill up the currently available memory with objects in the old generation gradually. 'The space-reclamation' reclaims space in the old generation incrementally.</p>
                </section>
                <section data-background="white">
                    <h3>Vs Parallel</h3>
                    <p>Parallel GC can compact and reclaim space in the old generation only as a whole.</p>
                    <p>G1 incrementally distributes this work across multiple much shorter collections.<p>
                    <p>This substantially shortens pause time at the potential expense of throughput.</p>
                </section>
                <section data-background="white">
                    <h3>VS CMS</h3>
                    <p>Similar to the CMS, G1 concurrently performs part of the old generation space-reclamation concurrently. However, CMS can’t defragment the old generation heap, eventually running into long Full GC's.</p>
                    <p>G1 can reclaim some completely empty, large areas of the old generation at any collection. This could avoid many otherwise unnecessary garbage collections, freeing a significant amount of space without much effort.</p>
                </section>
                <section data-background="white">
                    <h3>Tunning</h3>
<pre><code class="bash" data-trim data-noescape>
# The goal for the maximum pause time.
-XX:MaxGCPauseMillis=200

#The goal for the maximum pause time interval. By default G1
#doesn’t set any goal, allowing G1 to perform garbage
#collections back-to-back in extreme cases.
-XX:GCPauseTimeInterval=ergo

#The maximum number of threads used for parallel work during
#garbage collection pauses. This is derived from the number
#of available threads of the computer that the VM runs on in
#the following way: if the number of CPU threads available to
#the process is fewer than or equal to 8, use that.
#Otherwise add five eighths of the threads greater than to
#the final number of threads.
-XX:ParallelGCThreads=ergo

#The maximum number of threads used for concurrent work.
#By default, this value is -XX:ParallelGCThreads divided by 4
-XX:ConcGCThreads=ergo

#Defaults for controlling the initiating heap occupancy
#indicate that adaptive determination of that value is turned on,
#and that for the first few collection cycles G1 will use an
#occupancy of 45% of the old generation as mark start threshold.
-XX:+G1UseAdaptiveIHOP
-XX:InitiatingHeapOccupancyPercent=45

#The set of the heap region size based on initial and maximum
#heap size. So that heap contains roughly 2048 heap regions.
#The size of a heap region can vary from 1 to 32 MB,
#and must be a power of 2.
-XX:G1HeapRegionSize=ergo

#The size of the young generation in total, which varies
#between these two values as percentages of the current Java
#heap in use
-XX:G1NewSizePercent=5
-XX:G1MaxNewSizePercent=60

#The allowed unreclaimed space in the collection set
#candidates as a percentage. G1 stops the space-reclamation
#phase if the free space in the collection set candidates is
#lower than that.
-XX:G1HeapWastePercent=5

#The expected length of the space-reclamation phase in a
#number of collections.
-XX:G1MixedGCCountTarget=8

#Old generation regions with higher live object occupancy
#than this percentage aren't collected in this space-reclamation phase.</td>
-XX:G1MixedGCLiveThresholdPercent=85
</code></pre>
                </section>
            </section>
            <section>
                <section data-background="black">
                    <h2>Streams Improvements</h2>
                    <img src="Images/streams.png" />
                </section>
                <section data-background="black">
                    <h2>A Java "Joke"?</h2>
                    <img src="Images/bart-duke.png" />
                </section>
                <section data-background="black">
                    <h2>Let's do serious coding</h2>
                    <img src="Images/serious_coding.gif" />
                </section>
            </section>
            <!--
            <section data-background="./Images/cat.gif">

                <section>
                    <h2>Example1.java</h2>
                    <pre><code class="hljava" data-trim contenteditable>
import java.util.Arrays;
import java.util.List;

public class Example1 {
public static void main(String[] args) {
List&lt;String&gt; myFirstStream
= Arrays.asList("a1", "a2", "b1", "c2", "c1");
myFirstStream.stream()
.filter(s -> s.startsWith("c"))
.map(String::toUpperCase)
.sorted()
.forEach(System.out::println);
}
}
                    </code></pre>
                </section>
            </section>


            <section data-background="#ffffff">
                <h2>Others</h2>
                <ol>
                    <li>JEP 110: HTTP/2 Client</li>
                    <li>JEP 226: UTF-8 Property Resource Bundles</li>
                </ol>
            </section>
            -->
            <section data-background="Images/questions.jpg">
                <h2>Thanks</h2>
            </section>
        </div>

    </div>

    <script src="./Scripts/head.js"></script>
    <script src="./Scripts/reveal.js"></script>
    <script src="./Scripts/highlight.pack.js"></script>
    <script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
                    { src: './Scripts/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: './Scripts/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: './Scripts/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
	</script>

</body>
</html>
